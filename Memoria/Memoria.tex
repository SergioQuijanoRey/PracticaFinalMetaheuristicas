\documentclass[11pt]{article}

% Paquetes
%===================================================================================================

% Establecemos los márgenes
\usepackage[a4paper, margin=1in]{geometry}

% Separacion entre parrafos
\setlength{\parskip}{1em}

% Paquete para incluir codigo
\usepackage{listings}

% Paquete para incluir imagenes
\usepackage{graphicx}
\graphicspath{ {./Imagenes/} }

% Para fijar las imagenes en la posicion deseada
\usepackage{float}

% Para que el codigo acepte caracteres en utf8
\lstset{literate=
  {á}{{\'a}}1 {é}{{\'e}}1 {í}{{\'i}}1 {ó}{{\'o}}1 {ú}{{\'u}}1
  {Á}{{\'A}}1 {É}{{\'E}}1 {Í}{{\'I}}1 {Ó}{{\'O}}1 {Ú}{{\'U}}1
  {à}{{\`a}}1 {è}{{\`e}}1 {ì}{{\`i}}1 {ò}{{\`o}}1 {ù}{{\`u}}1
  {À}{{\`A}}1 {È}{{\'E}}1 {Ì}{{\`I}}1 {Ò}{{\`O}}1 {Ù}{{\`U}}1
  {ä}{{\"a}}1 {ë}{{\"e}}1 {ï}{{\"i}}1 {ö}{{\"o}}1 {ü}{{\"u}}1
  {Ä}{{\"A}}1 {Ë}{{\"E}}1 {Ï}{{\"I}}1 {Ö}{{\"O}}1 {Ü}{{\"U}}1
  {â}{{\^a}}1 {ê}{{\^e}}1 {î}{{\^i}}1 {ô}{{\^o}}1 {û}{{\^u}}1
  {Â}{{\^A}}1 {Ê}{{\^E}}1 {Î}{{\^I}}1 {Ô}{{\^O}}1 {Û}{{\^U}}1
  {ã}{{\~a}}1 {ẽ}{{\~e}}1 {ĩ}{{\~i}}1 {õ}{{\~o}}1 {ũ}{{\~u}}1
  {Ã}{{\~A}}1 {Ẽ}{{\~E}}1 {Ĩ}{{\~I}}1 {Õ}{{\~O}}1 {Ũ}{{\~U}}1
  {œ}{{\oe}}1 {Œ}{{\OE}}1 {æ}{{\ae}}1 {Æ}{{\AE}}1 {ß}{{\ss}}1
  {ű}{{\H{u}}}1 {Ű}{{\H{U}}}1 {ő}{{\H{o}}}1 {Ő}{{\H{O}}}1
  {ç}{{\c c}}1 {Ç}{{\c C}}1 {ø}{{\o}}1 {å}{{\r a}}1 {Å}{{\r A}}1
  {€}{{\euro}}1 {£}{{\pounds}}1 {«}{{\guillemotleft}}1
  {»}{{\guillemotright}}1 {ñ}{{\~n}}1 {Ñ}{{\~N}}1 {¿}{{?`}}1 {¡}{{!`}}1
}

% Para que no se salgan las lineas de codigo
% Para fijar una fuente que resalte
\lstset{breaklines=true, basicstyle=\ttfamily}


% Para que los metadatos que escribe latex esten en español
\usepackage[spanish]{babel}
\decimalpoint % Para que no se cambie el punto a la coma

% Para la bibliografia
% Sin esto, los enlaces de la bibliografia dan un error de compilacion
\usepackage{url}

% Para enlaces clickables
\usepackage{hyperref}

% Para mostrar graficas de dos imagenes, cada una con su caption, y con un caption comun
\usepackage{subcaption}

% Simbolo de los numeros reales
\usepackage{amssymb}

% Para que los codigos tengan una fuente distinta
\usepackage{courier}

\lstdefinestyle{CustomStyle}{
  language=Python,
  numbers=left,
  stepnumber=1,
  numbersep=10pt,
  tabsize=4,
  showspaces=false,
  showstringspaces=false
  basicstyle=\tiny\ttfamily,
}

% Para incluir tablas en csv
\usepackage{csvsimple}

% Para referenciar secciones usando el nombre de las secciones
\usepackage{nameref}

% Para enumerados dentro de enumerados
\usepackage{enumitem}

% Para mejores tablas
\usepackage{tabularx}

% Para poder tener el mismo identificador en dos tablas separadas
\usepackage{caption}

% Mostrar la página de las referencias en el indice del documento
\usepackage[nottoc,numbib]{tocbibind}

% Para mostrar las matrices
\usepackage{amsmath}

% Metadatos del documento
%===================================================================================================
\title{
    {Metaheurísticas - Proyecto Final}\\
    {\emph{Battle Royale Metaheuristic}}\\
    {\emph{Cec17 Competition}}
}

\author{
    {Sergio Quijano Rey - 72103503k}\\
    {sergioquijano@correo.ugr.es} \\
    {4º Doble Grado Ingeniería Informática y Matemáticas}
}

\date{\today}

% Separacion entre parrafos
\setlength{\parskip}{1em}

% Contenido del documento
%===================================================================================================
\begin{document}

% Portada del documento
\maketitle
\pagebreak

% Indice de contenidos
\tableofcontents

% Lista de figuras
\listoffigures

% Lista de tablas
\listoftables

\pagebreak
\section{Identificación del problema a resolver}

El problema a resolver consiste en realizar una propuesta de metaheurística original para problemas de codificación real. A partir de esta propuesta, realizaremos una implementación de dicha metaheurística original, y trabajaremos la competición \emph{Cec17}.

Para trabajar con dicha competición, usaremos el \emph{software} desarrollado por Daniel Molina, que se encuentra en \cite{daniel_repo:online}. En dicho repositorio encontramos el siguiente \emph{software}:

\begin{itemize}
    \item Librería escrita en \lstinline{C} que define las 31 funciones de \emph{fitness} que debemos optimizar, para las distintas dimensiones disponibles, así como otras funcionalidades
    \item Código \lstinline{python} para generar unas tablas \emph{Excel} que poder usar en \href{tacolab.org} para comparar con otros algoritmos de referencia
    \item Wrapper para \lstinline{Python}, con el que podemos acceder a todas las funciones definidas en la ya mencionada librería dinámica
\end{itemize}

En nuestro caso, como indicaron los profesores de la asignatura, por problemas con los tiempos de cómputo, trabajaremos con dimensión 10 y 30. Además, repetiremos por cada función y por cada dimensión, 10 ejecuciones distintas.

Por tanto, usamos un \emph{fork} de este repositorío para desarrollar nuestro trabajo, que se encuentra en \cite{repositorio:online}.

\pagebreak
\section{Descripción de la metaheurística} \label{descripcion}

\subsection{Propuesta original}

La metaheurística se basa en un género de videojuegos conocido como \emph{Battle Royale}. La dinámica de estos videojuegos se inspiran fuertemente en la serie de libros y posteriores películas `\emph{Los juegos del Hambre}', por lo que si el lector está familiarizado con estas novelas le será fácil seguir la siguiente explicación:

Una serie de jugadores (entre 50 y 100) se reparten a lo largo de un mapa. El objetivo es ser el último jugador vivo durante la partida. Para ello, tienen que seguir una serie de dinámicas durante la partida:

En primer lugar, al principio de la partida, los jugadores deben recolectar armas y otros recursos, porque todos los jugadores aparecen en el mapa sin equipación alguna. Esto puede verse reflejado en la metaheurística como una primera búsqueda local, muy suave, aplicada a las soluciones iniciales aleatorias

En segundo lugar, los jugadores deben matar y defenderse de los otros jugadores con los que se pueden encontrar a través del mapa. Para reflejar esto, si dos soluciones están muy cerca la una de la otra, estas dos soluciones compiten entre sí. El mejor jugador, que está mejor equipado, tiene una probabilidad alta de ganar la pelea, matando al otro jugador. Sin embargo, el peor jugador tiene una probabilidad pequeña de matar al mejor jugador (en el juego, puedes ir mejor equipado, pero perder el duelo por ser un jugador menos habilidoso). Soluciones muy cerca en el sentido en el que cierta distancia de los vectores que representan las dos soluciones estén por debajo de un valor dado.

En tercer lugar, a partir de cierto tiempo, el mapa se cierra incrementalmente sobre un área circular del mapa, cada vez más pequeña. Con esto se fomenta que los jugadores tengan que enfrentarse unos con otros, y potenciando que los jugadores mejor equipados y más habilidosos ganen sin tener que esperar demasiado tiempo a malos jugadores escondidos por el mapa.

Para representar esto en la metaheurística, a partir de cierta iteración, se realizarán eliminaciones de la población. A partir de este momento, cada cierto número de iteraciones, los $\lambda$ peores elementos de la población, son eliminados al quedar fuera del círculo.


La siguiente imagen, extraída de \cite{other_paper:paper}, ilustra de forma clara cuál es la mecánica del cierre del círculo:

\begin{figure}[H]
    \centering
    \includegraphics[width=0.6\textwidth]{cierre_circulo}
    \caption{Ilustración de la mecánica del cierre del círculo}
\end{figure}

Notar que la idea más natural para representar esta mecánica es cerrar el círculo sobre el espacio de búsqueda. Sin embargo, es una mala decisión, pues estamos restringiendo arbitrariamente soluciones en los bordes del espacio de búsqueda real, donde pueden encontrarse soluciones de buena calidad. Es por tanto que preferimos materializar la idea del círculo que se cierra sobre el fitness de los jugadores en referencia al mejor jugadr en vez de restringir el espacio de búsqueda.

En cuarto lugar, hay una cierta probabilidad de revivir si un jugador muere, aunque no es muy alta. Cuando un jugador revive, reaparece sin nada de lo que habías estado recolectando durante la partida. Se otorga un periodo de inmunidad en el que el jugador que ha revivido tiene que recolectar rápidamente recursos para ser competitivo contra jugadores que van más avanzados en la partida. Además, puede ser que reaparezcan fuera del círculo, luego deben lograr entrar al círculo en el tiempo de gracia

Por tanto, si un jugador muere, tiene una probabilidad dada (potencialmente baja) de revivir. Al revivir, pierde todos sus recursos. Esto se materializa en que se le asigna una solución aleatoria. En nomenclatura de nuestra metaheurística, reaparece en una posición aleatoria. Además, el periodo de gracia se materializa en que dispondrá de un número de iteraciones de una búsqueda local suave,  para intentar ser competitivo con el resto de soluciones que llevan toda la partida mejorando su fitness.

Decidimos también que, si un jugador muere contra el mejor jugador hasta el momento, revive siempre. Esto no se aplica cuando quedan menos de un número dado de jugadores (fase final de la partida)

Además de esto, consideramos algunos aspectos generales a todas las metaheurísticas vistas en clase:

En las distintas iteraciones, realizaremos una búsqueda local suave sobre las soluciones (para representar el movimiento por el mapa de los jugadores en la partida). Y como es habitual, partiremos de una población inicial aleatoria de jugadores. En el propio juego, los jugadores saltan desde el cielo eligiendo la posición inicial, y por tanto, podemos modelar este comportamiento como aleatorio.

\subsection{Modificaciones a la propuesta original}

Como era de esperar, esta propuesta original debe ser modificada ligeramente, pues algunas decisiones a nivel de ingeniería tienen más sentido. Las modificaciones que hemos considerado tras experimentar con la implementación de la metaheurística (implementación que se desarrollará en \emph{\ref{implementacion}. \nameref{implementacion}}) son las siguientes:

\begin{itemize}
    \item En un principio habíamos pensado en emplear la distancia euclídea para comprobar si dos jugadores estaban demasiado cerca. Sin embago, acabamos usando la distancia Manhattan porque es más rápida de computar. Esta distancia viene dada por $$\sum |w_i|$$ donde los coeficientes se definen como $$w := jugador_1 - jugador_2$$
    \item La mecánica de eliminar a los $\lambda$ peores jugadores en cada iteración, a partir de cierto momento, provoca que perdamos mucha variedad en la población prematuramente. En vez de eso, definimos un porcentaje que, a partir de un valor del radio del círculo $r$ por encima de $1.0$, que va descendiendo iteración tras iteración hasta llegar a $r = 1.0$. En cada iteración se eliminan los jugadores con \emph{fitness} más de $r$ veces peor que el \emph{fitness} de la mejor solución (recordad que estamos en un problema de minimización de las funciones objetivo)
    \item Tras hacer \emph{parameter tuning} en la sección \emph{\ref{tuning}. \nameref{tuning}}, la probabilidad de revivir acaba siendo 0.5, para nada es una probabilidad baja
    \item Por su poca relevancia, ignoramos la parte en la que comentamos que si un jugador muere contra el mejor jugador, forzosamente revive
\end{itemize}

\subsection{Trabajo existente}

En el \emph{paper} \cite{other_paper:paper}, se presenta una metaheurística basada también en este género de videojuegos. Sin embargo, en el proceso empleado para materializarla en una metaheurística concreta se toman decisiones completamente distintas a las que se presentan en este  trabajo. Por tanto, aunque la inspiración sea común, en la práctica las dos metaheurística son significativamente distintas.

En \cite{other_paper:paper}, cuando dos jugadores están cerca, se disparan entre ellos. Esto tiene dos efectos. El primero, el jugador que recibe el disparo aumenta en uno el contador de disparos recibido. Cuando el contador llega a un valor fijado, el jugador muere y resucita en un punto aleatorio del mapa. En segundo lugar, el jugador que recibe el disparo se mueve para evitar recibir más disparos. Este movimiento se hace en dirección hacia el mejor jugador.

Así, la propuesta \cite{other_paper:paper} considera una población de tamaño fijo, que no decrece como nuestra población, pues nuestra probabilidad de resucitar está por debajo de $1.0$. En segundo lugar, en las batallas no incluimos el mecanismo de movernos por el mapa. Usamos una búsqueda local suave para movernos por el mapa, en ningún momento queremos converger hacia la posición del mejor jugador.

\pagebreak
\section{Implementación de la metaheurística} \label{implementacion}

El desarrollo de esta metaheurística se ha realizado en \lstinline{python}, debido al rápido desarrollo que permite este lenguaje y la disponibilidad de \emph{wrappers} para el lenguaje gracias a \cite{daniel_repo:online}.

El proceso de instalación y ejecución del software se desarrolla en el \emph{Readme} del repositorio en el que tenemos alojado el código \cite{repositorio:online}, y por tanto no describimos de nuevo este proceso de instalación y ejecución necesario para trabajar con nuestra implementación.

Pasamos a comentar algunos aspectos clave de la implementación (no todo el código en general, que está a nuestro modo de ver lo suficientemente bien documentado como para que sea muy sencillo de leer).

\subsection{Pseudocódigo de la metaheurística}

Comentamos en primer lugar el pseudocódigo general de la metaheurística, que seguirá las ideas comentadas en \emph{\ref{descripcion}. \nameref{descripcion}}:

\begin{lstlisting}[language = python]
# Iniciamos una poblacion aleatoria
population = random_population(number of players)

# Condiciones para permanecer en la fase 1
phase1_condition = evals < max_evals and population.remaining_players() >= phase1_players_percentage
while pase1_condition:
    # Cada jugador se mueve por el mapa
    for player in population.players:
        player.soft_local_search()

    # Ronda de asesinatos entre jugadores cercanos
    # El primer jugador se elige aleatoriamente
    player1 = population.random_player

    # Se escoge un numero fijo de jugadores. Estos son los mas cercanos al player1
    players = n fijo jugadores mas cercanos a player1

    # Realizamos los asesinatos
    for player2 in players:
        # Los jugadores deben estar en un radio de vision
        if player1 no ve a player2:
            continue

        dead_player, resucitar = competir(player1, player2)
        if resucitar:
            # Aparece en una posicion aleatoria del mapa y tiene un periodo de gracia
            dead_player.respawn()
            dead_player.grace_time()


        # Si el jugador que muere es el player1, paramos
        if dead_player == player1 and resucitar == False:
            break

# Comienza la fase 2
circle_size = init_circle_size
while no se han consumido todas las iteraciones:
    # Los jugadores fuera del circulo mueren
    # Algunos pueden resucitar, haciendo player.respawn() y despues player.grace_time()
    population.kill_players_outside_circle()

    # Los jugadores se mueven algo
    for player in population.players:
        player.soft_local_search()


    # El circulo se cierra
    circle_size += circle_step

    # Si solo queda un jugador, paramos de iterar
    if len(population) == 1:
        break

# Devolvemos el mejor jugador
return population.get_best_player()
\end{lstlisting}

La búsqueda local suave utilizada se describe en el siguiente pseudocódigo:

\begin{lstlisting}
def soft_local_search(self):
    best_player = self

    for _ in 0..tries_in_local_search:
        # Se selecciona la coordenada y el valor de variacion de forma aleatoria
        position = random(0, len(self.position))
        delta = random(step_size, step_size)

        # Modificamos la posicion
        new_position = self.position.copy()
        new_position[position] = new_position[position] + delta

        # Generamos el nuevo jugador
        new_player = None
        new_player = Player(self.dimension, new_position)

        # Si el jugador no es valido, lo ignoramos
        if new_player.is_valid == False:
            continue

        # Comprobamos si es mejor que el mejor jugador hasta el momento
        new_pla_fit = new_player.fitness()
        if new_player.fitness() < best_player.fitness():
            best_player = new_player


    # Hacemos el cambio mas optimo
    self = best_player
\end{lstlisting}


Con este pseudocódigo en mente, podemos describir algunos detalles relevantes de la implementación.

\subsection{Clase \lstinline{Config}}

La clase \lstinline{Config} centraliza todos los parámetros que hemos fijado en nuestra metaheurística. Los atributos estáticos hace que sea fácil acceder a parámetros comunes en distintas partes del código sin una penalización en tiempos de ejecución aparentemente relevante.

Además, como se hace en la función \lstinline{parameter_tuning} de \lstinline{main.py}, podemos modificar estos atributos estáticos para ver cómo afecta esto al rendimiento de nuestra metaheurística.

\subsection{Clase \lstinline{EvalsCounter}}

Esta clase se implementa con el uso del patrón \emph{Singleton}. Su objetivo es centralizar la cuenta de evaluaciones del \emph{fitness} consumidas hasta el momento, sin tener que pasar a todos los métodos una parámetro adicional.

Sin embargo, sospechamos que esto sí que puede introducir una penalización en tiempo de ejecución. Pero al estar escribiendo un primer prototipo, vale más la pena trabajar con un código mas sencillo en el que es más rápido realizar cambios sobre la marcha (como hemos tenido que realizar, al no tener una metaheurística ya desarrollado con un funcionamiento bueno asegurado).

En una versión mejorada en la que los tiempos de ejecución sean más críticos, evitar este patrón \emph{Singleton} es obligado.

\subsection{Clase \lstinline{Player}}

Define un jugador. Principalmente, viene dado por las coordenadas en las que se encuentra, que vienen dadas por \lstinline{self.position}.

Por motivos de eficiencia, \emph{cacheamos} el valor del \emph{fitness}, para evitar desperdiciar evaluaciones del \emph{fitness}. Del mismo modo, en la propia lógica que maneja la cache, usamos el \emph{Singleton} que ya hemos comentado para llevar la cuenta de todas las evaluaciones del \emph{fitness} consumidas.

\subsection{Clase \lstinline{Population}}

Representa al conjunto de jugadores. Permite inicializar poblaciones de jugadores aleatorias, aplicar búsquedas locales sobre todos los jugadores de la población, matar a los jugadores fuera del círculo, tomar al mejor jugador de la población, aplicar periodos de gracia a jugadores resucitados, \ldots

\subsection{Clase \lstinline{BattleRoyale}}

Representa el código de alto nivel de la metaheurística, principalmente lanzando el código necesario para la primera y segunda fase. Usa los métodos que la clase \lstinline{Population} ofrece para realizar operaciones sobre toda la población ya comentadas, y para realizar las comprobaciones que determinan en qué fase de la metaheurística nos encontramos.

El método más importante es \lstinline{run_game}, que permite lanzar la ejecución de la metaheurística.

\subsection{\emph{Parameter Tuning}} \label{tuning}

Si se consulta la clase \lstinline{Config}, se pueden consultar todos los parámetros libre que hemos tenido que establecer en nuestra metaheurística. A continuación se da una breve descripción de cada uno de ellos:

\begin{itemize}
    \item \lstinline{lower_range}, \lstinline{upper_range}: el rango de las funciones reales con las que trabajamos. En cada coordenada, trabajamos con el rango $[-100, 100]$
    \item \lstinline{number_of_players}: número de jugadores iniciales cuando comienza una partida
    \item \lstinline{ev_per_dimension}: evaluaciones del fitness por cada dimensión del problema. Es un valor fijado a $10.000$
    \item \lstinline{phase1_percentage}: porcentaje de evaluaciones máximas que reservamos para la primera fase de la partida
    \item \lstinline{phase1_players_percentage}: porcentaje mínimo de jugadores con los que puede finalizar la primera fase de la partida
    \item \lstinline{tries_in_local_search}: intentos que se pueden emplear en la búsqueda local suave
    \item \lstinline{step_size}: tamaño de salto para la búsqueda local
    \item \lstinline{player_radius_vision_per_dimension}: radio de visión de los jugadores
    \item \lstinline{players_to_compete}: número de jugadores con los que compite el jugador aleatorio escogido
    \item \lstinline{best_player_survives_prob}: probabilidad de que el mejor jugador sobreviva en una batalla
    \item \lstinline{resurrect_prob}: probabilidad de resurrección
    \item \lstinline{number_of_grace_soft_local_search}: número de búsquedas locales suaves que se usan cuando un jugador revive como tiempo de gracia
    \item \lstinline{init_circle_size}: tamaño inicial del círculo
    \item \lstinline{circle_step}: controla el cerrado del círculo
\end{itemize}

Por tanto, debemos buscar un método para fijar unos valores de estos parámetros, lo más óptimos posibles empleando un tiempo de computación razonable. El proceso ideal sería emplear \emph{Grid Search} sobre todas las combinaciones de los parámetros libres que queramos explorar. Sin embargo, esto no es factible en un tiempo razonable, y por tanto empleamos otro enfoque más rápido aunque subóptimo.

Empleamos una combinación de búsqueda binaria con la técnica \emph{Coordinate Descent}. Elegimos un parámetro libre a optimizar. Realizamos sucesivas búsquedas binarias hasta encontrar un valor óptimo para el parámetro. Tras esto, realizamos el mismo proceso iterativamente con las parámetros libres restantes.

Este proceso lo realizamos de forma manual usando la función \lstinline{parameter_tuning} del fichero \lstinline{main.py}. Los resultados en bruto de este proceso se muestran en el fichero \lstinline{parameter_tuning/parameter_tuning_results.txt}. Resumimos los resultados en las siguientes tablas:

\pagebreak
\section{Resultados de la metaheurística}

\pagebreak
\section{Hibridación con la búsqueda local \emph{Solis West}}

\subsection{Parameter Tuning para la hibridación}

Los nuevos parámetros con los que tenemos que trabajar son:

\begin{itemize}
    \item \lstinline{max_evals_hard_local_search}: máximo de evaluaciones que permitimos por cada búsqueda local
    \item \lstinline{delta}: valor que controlar el comportamiento de la búsqueda \emph{Solis West}
\end{itemize}

\pagebreak
\section{Resultados de la hibridación}

\pagebreak
\section{Propuesta de mejoras} \label{mejoras}

% Evitar el singleton, como ya se ha comentado -> Eficiencia, antipatron, no permite paralelizacion
% Demasiados parametros. Usar parametros adaptativos para no tener que emplear parameter tuning altamente costoso computacionalmente cuando

\pagebreak

% Bibliografia
\bibliography{./References}
\bibliographystyle{acm}

\end{document}
